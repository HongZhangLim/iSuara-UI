package com.isuara.app.ml

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import com.google.mediapipe.framework.image.BitmapImageBuilder
import com.google.mediapipe.framework.image.MPImage
import com.google.mediapipe.tasks.core.BaseOptions
import com.google.mediapipe.tasks.core.Delegate
import com.google.mediapipe.tasks.vision.core.RunningMode
import com.google.mediapipe.tasks.vision.handlandmarker.HandLandmarker
import com.google.mediapipe.tasks.vision.handlandmarker.HandLandmarkerResult
import com.google.mediapipe.tasks.vision.poselandmarker.PoseLandmarker
import com.google.mediapipe.tasks.vision.poselandmarker.PoseLandmarkerResult
import java.util.concurrent.ConcurrentHashMap

class LandmarkExtractor(
    context: Context,
    private val onResult: (FloatArray?, Long) -> Unit // PINPOINT: Fixes "Too many arguments"
) {

    companion object {
        private const val TAG = "LandmarkExtractor"
    }

    private var poseLandmarker: PoseLandmarker? = null
    private var handLandmarker: HandLandmarker? = null

    private class FrameResult {
        var poseDone = false
        var handDone = false
        var features: FloatArray? = null
        var hasData = false
        var isFrontCamera = true // Added this flag
    }
    private val pendingFrames = ConcurrentHashMap<Long, FrameResult>()

    init {
        // Use CPU for stability, LIVE_STREAM for 30+ FPS performance
        val poseOptions = PoseLandmarker.PoseLandmarkerOptions.builder()
            .setBaseOptions(BaseOptions.builder().setModelAssetPath("pose_landmarker_lite.task").setDelegate(Delegate.CPU).build())
            .setRunningMode(RunningMode.LIVE_STREAM)
            .setResultListener(this::onPoseResult)
            .build()

        val handOptions = HandLandmarker.HandLandmarkerOptions.builder()
            .setBaseOptions(BaseOptions.builder().setModelAssetPath("hand_landmarker.task").setDelegate(Delegate.CPU).build())
            .setRunningMode(RunningMode.LIVE_STREAM)
            .setNumHands(2)
            .setResultListener(this::onHandResult)
            .build()

        poseLandmarker = PoseLandmarker.createFromOptions(context, poseOptions)
        handLandmarker = HandLandmarker.createFromOptions(context, handOptions)
    }

    // Added isFrontCamera parameter
    fun extractAsync(bitmap: Bitmap, timestampMs: Long, isFrontCamera: Boolean) {
        val image = BitmapImageBuilder(bitmap).build()

        val frame = FrameResult()
        frame.isFrontCamera = isFrontCamera // Save the flag for this specific frame
        pendingFrames[timestampMs] = frame

        poseLandmarker?.detectAsync(image, timestampMs)
        handLandmarker?.detectAsync(image, timestampMs)
    }

    private fun onPoseResult(result: PoseLandmarkerResult, image: MPImage) {
        val ts = result.timestampMs()
        val frame = pendingFrames[ts] ?: return

        // THE FIX: A map to swap Left and Right body landmarks (eyes, ears, shoulders, wrists, etc.)
        val POSE_SWAP_MAP = intArrayOf(
            0,  // 0: nose
            4, 5, 6, // 1,2,3 -> 4,5,6 (eyes)
            1, 2, 3, // 4,5,6 -> 1,2,3 (eyes)
            8, 7,    // 7,8 -> 8,7 (ears)
            10, 9,   // 9,10 -> 10,9 (mouth)
            12, 11,  // 11,12 -> 12,11 (shoulders)
            14, 13,  // 13,14 -> 14,13 (elbows)
            16, 15,  // 15,16 -> 16,15 (wrists)
            18, 17,  // 17,18 -> 18,17 (pinkies)
            20, 19,  // 19,20 -> 20,19 (indexes)
            22, 21,  // 21,22 -> 22,21 (thumbs)
            24, 23,  // 23,24 -> 24,23 (hips)
            26, 25,  // 25,26 -> 26,25 (knees)
            28, 27,  // 27,28 -> 28,27 (ankles)
            30, 29,  // 29,30 -> 30,29 (heels)
            32, 31   // 31,32 -> 32,31 (foot indexes)
        )

        synchronized(frame) {
            if (frame.features == null) frame.features = FloatArray(258)
            if (result.landmarks().isNotEmpty()) {
                frame.hasData = true
                val poseLms = result.landmarks()[0]
                for (i in 0 until 33) {

                    // THE FIX: Use the swapped index for the rear camera!
                    val mappedIndex = if (frame.isFrontCamera) i else POSE_SWAP_MAP[i]
                    val idx = mappedIndex * 4
                    val rawX = poseLms[i].x()

                    frame.features!![idx] = if (frame.isFrontCamera) rawX else (1f - rawX)
                    frame.features!![idx + 1] = poseLms[i].y()
                    frame.features!![idx + 2] = poseLms[i].z()
                    frame.features!![idx + 3] = poseLms[i].visibility().orElse(0f)
                }
            }
            frame.poseDone = true
            checkCompletion(ts, frame)
        }
    }

    private fun onHandResult(result: HandLandmarkerResult, image: MPImage) {
        val ts = result.timestampMs()
        val frame = pendingFrames[ts] ?: return
        synchronized(frame) {
            if (frame.features == null) frame.features = FloatArray(258)
            if (result.landmarks().isNotEmpty()) {
                frame.hasData = true
                for (i in result.landmarks().indices) {
                    var isLeft = result.handednesses()[i][0].categoryName() == "Left"

                    // THE FIX: Swap hand labels for the rear camera
                    if (!frame.isFrontCamera) {
                        isLeft = !isLeft
                    }

                    val offset = if (isLeft) 132 else 195
                    for (j in 0 until 21) {
                        val idx = offset + (j * 3)
                        val rawX = result.landmarks()[i][j].x()

                        // THE FIX: Mathematically mirror X for the rear camera
                        frame.features!![idx] = if (frame.isFrontCamera) rawX else (1f - rawX)

                        frame.features!![idx+1] = result.landmarks()[i][j].y()
                        frame.features!![idx+2] = result.landmarks()[i][j].z()
                    }
                }
            }
            frame.handDone = true
            checkCompletion(ts, frame)
        }
    }

    private fun checkCompletion(ts: Long, frame: FrameResult) {
        if (frame.poseDone && frame.handDone) {
            pendingFrames.remove(ts)
            onResult(if (frame.hasData) frame.features else null, ts)
        }
    }

    fun close() {
        poseLandmarker?.close()
        handLandmarker?.close()
    }
}